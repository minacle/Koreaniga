// This file is automatically generated by GYB: Generate Your Boilerplate
// DO NOT EDIT

import Foundation

public protocol KoreanigaProtocol: CustomStringConvertible, CustomDebugStringConvertible {

    var string: String {get}
}

public enum Koreaniga {

    public struct Gwa_Wa: KoreanigaProtocol {

        public let string: String

        fileprivate let postpositionForAnyConsonant: String
        fileprivate let postpositionForAnyVowel: String

        public var description: String {
            let decomposed = self.string.decomposedStringWithCanonicalMapping
            var postposition: String?
            for scalar in decomposed.unicodeScalars.reversed() {
                switch UInt(scalar.value) {
                case 0x1161 ... 0x1175:
                    postposition = self.postpositionForAnyVowel
                case 0x11a8 ... 0x11c2:
                    postposition = self.postpositionForAnyConsonant
                default:
                    continue
                }
                break
            }
            if postposition == nil {
                if self.postpositionForAnyVowel.isEmpty {
                    postposition = "(\(self.postpositionForAnyConsonant))"
                }
                else {
                    let postpositionForAnyConsonant: String
                    let postpositionForAnyVowel: String
                    if self.postpositionForAnyConsonant.hasSuffix(self.postpositionForAnyVowel) {
                        postpositionForAnyConsonant = String(self.postpositionForAnyConsonant[..<(self.postpositionForAnyConsonant.index(self.postpositionForAnyConsonant.endIndex, offsetBy: self.postpositionForAnyVowel.count - self.postpositionForAnyConsonant.count))])
                    }
                    else {
                        postpositionForAnyConsonant = self.postpositionForAnyConsonant
                    }
                    postpositionForAnyVowel = self.postpositionForAnyVowel
                    if !postpositionForAnyConsonant.isEmpty {
                        postposition = "(\(postpositionForAnyConsonant))\(postpositionForAnyVowel)"
                    }
                    else {
                        postposition = postpositionForAnyVowel
                    }
                }
            }
            return self.string + (postposition ?? "")
        }

        public var debugDescription: String {
            var postposition: String?
            let postpositionForAnyConsonant: String
            let postpositionForAnyVowel: String
            if self.postpositionForAnyConsonant.hasSuffix(self.postpositionForAnyVowel) {
                postpositionForAnyConsonant = String(self.postpositionForAnyConsonant[..<(self.postpositionForAnyConsonant.index(self.postpositionForAnyConsonant.endIndex, offsetBy: self.postpositionForAnyVowel.count - self.postpositionForAnyConsonant.count))])
            }
            else {
                postpositionForAnyConsonant = self.postpositionForAnyConsonant
            }
            postpositionForAnyVowel = self.postpositionForAnyVowel
            if !postpositionForAnyConsonant.isEmpty {
                postposition = "(\(postpositionForAnyConsonant))\(postpositionForAnyVowel)"
            }
            else {
                postposition = postpositionForAnyVowel
            }
            return self.string + (postposition ?? "")
        }

        fileprivate init
            (string: String,
             postpositionForAnyConsonant: String = "과",
             postpositionForAnyVowel: String = "와")
        {
            self.string = string
            self.postpositionForAnyConsonant = postpositionForAnyConsonant
            self.postpositionForAnyVowel = postpositionForAnyVowel
        }
    }

    public struct A_Ya: KoreanigaProtocol {

        public let string: String

        fileprivate let postpositionForAnyConsonant: String
        fileprivate let postpositionForAnyVowel: String

        public var description: String {
            let decomposed = self.string.decomposedStringWithCanonicalMapping
            var postposition: String?
            for scalar in decomposed.unicodeScalars.reversed() {
                switch UInt(scalar.value) {
                case 0x1161 ... 0x1175:
                    postposition = self.postpositionForAnyVowel
                case 0x11a8 ... 0x11c2:
                    postposition = self.postpositionForAnyConsonant
                default:
                    continue
                }
                break
            }
            if postposition == nil {
                if self.postpositionForAnyVowel.isEmpty {
                    postposition = "(\(self.postpositionForAnyConsonant))"
                }
                else {
                    let postpositionForAnyConsonant: String
                    let postpositionForAnyVowel: String
                    if self.postpositionForAnyConsonant.hasSuffix(self.postpositionForAnyVowel) {
                        postpositionForAnyConsonant = String(self.postpositionForAnyConsonant[..<(self.postpositionForAnyConsonant.index(self.postpositionForAnyConsonant.endIndex, offsetBy: self.postpositionForAnyVowel.count - self.postpositionForAnyConsonant.count))])
                    }
                    else {
                        postpositionForAnyConsonant = self.postpositionForAnyConsonant
                    }
                    postpositionForAnyVowel = self.postpositionForAnyVowel
                    if !postpositionForAnyConsonant.isEmpty {
                        postposition = "(\(postpositionForAnyConsonant))\(postpositionForAnyVowel)"
                    }
                    else {
                        postposition = postpositionForAnyVowel
                    }
                }
            }
            return self.string + (postposition ?? "")
        }

        public var debugDescription: String {
            var postposition: String?
            let postpositionForAnyConsonant: String
            let postpositionForAnyVowel: String
            if self.postpositionForAnyConsonant.hasSuffix(self.postpositionForAnyVowel) {
                postpositionForAnyConsonant = String(self.postpositionForAnyConsonant[..<(self.postpositionForAnyConsonant.index(self.postpositionForAnyConsonant.endIndex, offsetBy: self.postpositionForAnyVowel.count - self.postpositionForAnyConsonant.count))])
            }
            else {
                postpositionForAnyConsonant = self.postpositionForAnyConsonant
            }
            postpositionForAnyVowel = self.postpositionForAnyVowel
            if !postpositionForAnyConsonant.isEmpty {
                postposition = "(\(postpositionForAnyConsonant))\(postpositionForAnyVowel)"
            }
            else {
                postposition = postpositionForAnyVowel
            }
            return self.string + (postposition ?? "")
        }

        fileprivate init
            (string: String,
             postpositionForAnyConsonant: String = "아",
             postpositionForAnyVowel: String = "야")
        {
            self.string = string
            self.postpositionForAnyConsonant = postpositionForAnyConsonant
            self.postpositionForAnyVowel = postpositionForAnyVowel
        }
    }

    public struct Eu: KoreanigaProtocol {

        public let string: String

        fileprivate let postpositionForAnyConsonant: String
        fileprivate let postpositionForRieul: String
        fileprivate let postpositionForAnyVowel: String

        public var ro: Koreaniga.EuRo_Ro {
            return Koreaniga.EuRo_Ro(string: self.string)
        }

        public var description: String {
            let decomposed = self.string.decomposedStringWithCanonicalMapping
            var postposition: String?
            for scalar in decomposed.unicodeScalars.reversed() {
                switch UInt(scalar.value) {
                case 0x1161 ... 0x1175:
                    postposition = self.postpositionForAnyVowel
                case 0x11af:
                    postposition = self.postpositionForRieul
                case 0x11a8 ... 0x11c2:
                    postposition = self.postpositionForAnyConsonant
                default:
                    continue
                }
                break
            }
            if postposition == nil {
                if self.postpositionForAnyVowel.isEmpty {
                    postposition = "(\(self.postpositionForAnyConsonant))"
                }
                else {
                    let postpositionForAnyConsonant: String
                    let postpositionForAnyVowel: String
                    if self.postpositionForAnyConsonant.hasSuffix(self.postpositionForAnyVowel) {
                        postpositionForAnyConsonant = String(self.postpositionForAnyConsonant[..<(self.postpositionForAnyConsonant.index(self.postpositionForAnyConsonant.endIndex, offsetBy: self.postpositionForAnyVowel.count - self.postpositionForAnyConsonant.count))])
                    }
                    else {
                        postpositionForAnyConsonant = self.postpositionForAnyConsonant
                    }
                    postpositionForAnyVowel = self.postpositionForAnyVowel
                    if !postpositionForAnyConsonant.isEmpty {
                        postposition = "(\(postpositionForAnyConsonant))\(postpositionForAnyVowel)"
                    }
                    else {
                        postposition = postpositionForAnyVowel
                    }
                }
            }
            return self.string + (postposition ?? "")
        }

        public var debugDescription: String {
            var postposition: String?
            let postpositionForAnyConsonant: String
            let postpositionForAnyVowel: String
            if self.postpositionForAnyConsonant.hasSuffix(self.postpositionForAnyVowel) {
                postpositionForAnyConsonant = String(self.postpositionForAnyConsonant[..<(self.postpositionForAnyConsonant.index(self.postpositionForAnyConsonant.endIndex, offsetBy: self.postpositionForAnyVowel.count - self.postpositionForAnyConsonant.count))])
            }
            else {
                postpositionForAnyConsonant = self.postpositionForAnyConsonant
            }
            postpositionForAnyVowel = self.postpositionForAnyVowel
            if !postpositionForAnyConsonant.isEmpty {
                postposition = "(\(postpositionForAnyConsonant))\(postpositionForAnyVowel)"
            }
            else {
                postposition = postpositionForAnyVowel
            }
            return self.string + (postposition ?? "")
        }

        fileprivate init
            (string: String,
             postpositionForAnyConsonant: String = "으",
             postpositionForRieul: String = "",
             postpositionForAnyVowel: String = "")
        {
            self.string = string
            self.postpositionForAnyConsonant = postpositionForAnyConsonant
            self.postpositionForRieul = postpositionForRieul
            self.postpositionForAnyVowel = postpositionForAnyVowel
        }
    }

    public struct EuRo_Ro: KoreanigaProtocol {

        public let string: String

        fileprivate let postpositionForAnyConsonant: String
        fileprivate let postpositionForRieul: String
        fileprivate let postpositionForAnyVowel: String

        public var description: String {
            let decomposed = self.string.decomposedStringWithCanonicalMapping
            var postposition: String?
            for scalar in decomposed.unicodeScalars.reversed() {
                switch UInt(scalar.value) {
                case 0x1161 ... 0x1175:
                    postposition = self.postpositionForAnyVowel
                case 0x11af:
                    postposition = self.postpositionForRieul
                case 0x11a8 ... 0x11c2:
                    postposition = self.postpositionForAnyConsonant
                default:
                    continue
                }
                break
            }
            if postposition == nil {
                if self.postpositionForAnyVowel.isEmpty {
                    postposition = "(\(self.postpositionForAnyConsonant))"
                }
                else {
                    let postpositionForAnyConsonant: String
                    let postpositionForAnyVowel: String
                    if self.postpositionForAnyConsonant.hasSuffix(self.postpositionForAnyVowel) {
                        postpositionForAnyConsonant = String(self.postpositionForAnyConsonant[..<(self.postpositionForAnyConsonant.index(self.postpositionForAnyConsonant.endIndex, offsetBy: self.postpositionForAnyVowel.count - self.postpositionForAnyConsonant.count))])
                    }
                    else {
                        postpositionForAnyConsonant = self.postpositionForAnyConsonant
                    }
                    postpositionForAnyVowel = self.postpositionForAnyVowel
                    if !postpositionForAnyConsonant.isEmpty {
                        postposition = "(\(postpositionForAnyConsonant))\(postpositionForAnyVowel)"
                    }
                    else {
                        postposition = postpositionForAnyVowel
                    }
                }
            }
            return self.string + (postposition ?? "")
        }

        public var debugDescription: String {
            var postposition: String?
            let postpositionForAnyConsonant: String
            let postpositionForAnyVowel: String
            if self.postpositionForAnyConsonant.hasSuffix(self.postpositionForAnyVowel) {
                postpositionForAnyConsonant = String(self.postpositionForAnyConsonant[..<(self.postpositionForAnyConsonant.index(self.postpositionForAnyConsonant.endIndex, offsetBy: self.postpositionForAnyVowel.count - self.postpositionForAnyConsonant.count))])
            }
            else {
                postpositionForAnyConsonant = self.postpositionForAnyConsonant
            }
            postpositionForAnyVowel = self.postpositionForAnyVowel
            if !postpositionForAnyConsonant.isEmpty {
                postposition = "(\(postpositionForAnyConsonant))\(postpositionForAnyVowel)"
            }
            else {
                postposition = postpositionForAnyVowel
            }
            return self.string + (postposition ?? "")
        }

        fileprivate init
            (string: String,
             postpositionForAnyConsonant: String = "으로",
             postpositionForRieul: String = "로",
             postpositionForAnyVowel: String = "로")
        {
            self.string = string
            self.postpositionForAnyConsonant = postpositionForAnyConsonant
            self.postpositionForRieul = postpositionForRieul
            self.postpositionForAnyVowel = postpositionForAnyVowel
        }
    }

    public struct Eun: KoreanigaProtocol {

        public let string: String

        fileprivate let postpositionForAnyConsonant: String
        fileprivate let postpositionForAnyVowel: String

        public var neun: Koreaniga.Eun_Neun {
            return Koreaniga.Eun_Neun(string: self.string)
        }

        public var description: String {
            let decomposed = self.string.decomposedStringWithCanonicalMapping
            var postposition: String?
            for scalar in decomposed.unicodeScalars.reversed() {
                switch UInt(scalar.value) {
                case 0x1161 ... 0x1175:
                    postposition = self.postpositionForAnyVowel
                case 0x11a8 ... 0x11c2:
                    postposition = self.postpositionForAnyConsonant
                default:
                    continue
                }
                break
            }
            if postposition == nil {
                if self.postpositionForAnyVowel.isEmpty {
                    postposition = "(\(self.postpositionForAnyConsonant))"
                }
                else {
                    let postpositionForAnyConsonant: String
                    let postpositionForAnyVowel: String
                    if self.postpositionForAnyConsonant.hasSuffix(self.postpositionForAnyVowel) {
                        postpositionForAnyConsonant = String(self.postpositionForAnyConsonant[..<(self.postpositionForAnyConsonant.index(self.postpositionForAnyConsonant.endIndex, offsetBy: self.postpositionForAnyVowel.count - self.postpositionForAnyConsonant.count))])
                    }
                    else {
                        postpositionForAnyConsonant = self.postpositionForAnyConsonant
                    }
                    postpositionForAnyVowel = self.postpositionForAnyVowel
                    if !postpositionForAnyConsonant.isEmpty {
                        postposition = "(\(postpositionForAnyConsonant))\(postpositionForAnyVowel)"
                    }
                    else {
                        postposition = postpositionForAnyVowel
                    }
                }
            }
            return self.string + (postposition ?? "")
        }

        public var debugDescription: String {
            var postposition: String?
            let postpositionForAnyConsonant: String
            let postpositionForAnyVowel: String
            if self.postpositionForAnyConsonant.hasSuffix(self.postpositionForAnyVowel) {
                postpositionForAnyConsonant = String(self.postpositionForAnyConsonant[..<(self.postpositionForAnyConsonant.index(self.postpositionForAnyConsonant.endIndex, offsetBy: self.postpositionForAnyVowel.count - self.postpositionForAnyConsonant.count))])
            }
            else {
                postpositionForAnyConsonant = self.postpositionForAnyConsonant
            }
            postpositionForAnyVowel = self.postpositionForAnyVowel
            if !postpositionForAnyConsonant.isEmpty {
                postposition = "(\(postpositionForAnyConsonant))\(postpositionForAnyVowel)"
            }
            else {
                postposition = postpositionForAnyVowel
            }
            return self.string + (postposition ?? "")
        }

        fileprivate init
            (string: String,
             postpositionForAnyConsonant: String = "은",
             postpositionForAnyVowel: String = "는")
        {
            self.string = string
            self.postpositionForAnyConsonant = postpositionForAnyConsonant
            self.postpositionForAnyVowel = postpositionForAnyVowel
        }
    }

    public struct Eun_Neun: KoreanigaProtocol {

        public let string: String

        fileprivate let postpositionForAnyConsonant: String
        fileprivate let postpositionForAnyVowel: String

        public var description: String {
            let decomposed = self.string.decomposedStringWithCanonicalMapping
            var postposition: String?
            for scalar in decomposed.unicodeScalars.reversed() {
                switch UInt(scalar.value) {
                case 0x1161 ... 0x1175:
                    postposition = self.postpositionForAnyVowel
                case 0x11a8 ... 0x11c2:
                    postposition = self.postpositionForAnyConsonant
                default:
                    continue
                }
                break
            }
            if postposition == nil {
                if self.postpositionForAnyVowel.isEmpty {
                    postposition = "(\(self.postpositionForAnyConsonant))"
                }
                else {
                    let postpositionForAnyConsonant: String
                    let postpositionForAnyVowel: String
                    if self.postpositionForAnyConsonant.hasSuffix(self.postpositionForAnyVowel) {
                        postpositionForAnyConsonant = String(self.postpositionForAnyConsonant[..<(self.postpositionForAnyConsonant.index(self.postpositionForAnyConsonant.endIndex, offsetBy: self.postpositionForAnyVowel.count - self.postpositionForAnyConsonant.count))])
                    }
                    else {
                        postpositionForAnyConsonant = self.postpositionForAnyConsonant
                    }
                    postpositionForAnyVowel = self.postpositionForAnyVowel
                    if !postpositionForAnyConsonant.isEmpty {
                        postposition = "(\(postpositionForAnyConsonant))\(postpositionForAnyVowel)"
                    }
                    else {
                        postposition = postpositionForAnyVowel
                    }
                }
            }
            return self.string + (postposition ?? "")
        }

        public var debugDescription: String {
            var postposition: String?
            let postpositionForAnyConsonant: String
            let postpositionForAnyVowel: String
            if self.postpositionForAnyConsonant.hasSuffix(self.postpositionForAnyVowel) {
                postpositionForAnyConsonant = String(self.postpositionForAnyConsonant[..<(self.postpositionForAnyConsonant.index(self.postpositionForAnyConsonant.endIndex, offsetBy: self.postpositionForAnyVowel.count - self.postpositionForAnyConsonant.count))])
            }
            else {
                postpositionForAnyConsonant = self.postpositionForAnyConsonant
            }
            postpositionForAnyVowel = self.postpositionForAnyVowel
            if !postpositionForAnyConsonant.isEmpty {
                postposition = "(\(postpositionForAnyConsonant))\(postpositionForAnyVowel)"
            }
            else {
                postposition = postpositionForAnyVowel
            }
            return self.string + (postposition ?? "")
        }

        fileprivate init
            (string: String,
             postpositionForAnyConsonant: String = "은",
             postpositionForAnyVowel: String = "는")
        {
            self.string = string
            self.postpositionForAnyConsonant = postpositionForAnyConsonant
            self.postpositionForAnyVowel = postpositionForAnyVowel
        }
    }

    public struct Eul: KoreanigaProtocol {

        public let string: String

        fileprivate let postpositionForAnyConsonant: String
        fileprivate let postpositionForAnyVowel: String

        public var reul: Koreaniga.Eul_Reul {
            return Koreaniga.Eul_Reul(string: self.string)
        }

        public var description: String {
            let decomposed = self.string.decomposedStringWithCanonicalMapping
            var postposition: String?
            for scalar in decomposed.unicodeScalars.reversed() {
                switch UInt(scalar.value) {
                case 0x1161 ... 0x1175:
                    postposition = self.postpositionForAnyVowel
                case 0x11a8 ... 0x11c2:
                    postposition = self.postpositionForAnyConsonant
                default:
                    continue
                }
                break
            }
            if postposition == nil {
                if self.postpositionForAnyVowel.isEmpty {
                    postposition = "(\(self.postpositionForAnyConsonant))"
                }
                else {
                    let postpositionForAnyConsonant: String
                    let postpositionForAnyVowel: String
                    if self.postpositionForAnyConsonant.hasSuffix(self.postpositionForAnyVowel) {
                        postpositionForAnyConsonant = String(self.postpositionForAnyConsonant[..<(self.postpositionForAnyConsonant.index(self.postpositionForAnyConsonant.endIndex, offsetBy: self.postpositionForAnyVowel.count - self.postpositionForAnyConsonant.count))])
                    }
                    else {
                        postpositionForAnyConsonant = self.postpositionForAnyConsonant
                    }
                    postpositionForAnyVowel = self.postpositionForAnyVowel
                    if !postpositionForAnyConsonant.isEmpty {
                        postposition = "(\(postpositionForAnyConsonant))\(postpositionForAnyVowel)"
                    }
                    else {
                        postposition = postpositionForAnyVowel
                    }
                }
            }
            return self.string + (postposition ?? "")
        }

        public var debugDescription: String {
            var postposition: String?
            let postpositionForAnyConsonant: String
            let postpositionForAnyVowel: String
            if self.postpositionForAnyConsonant.hasSuffix(self.postpositionForAnyVowel) {
                postpositionForAnyConsonant = String(self.postpositionForAnyConsonant[..<(self.postpositionForAnyConsonant.index(self.postpositionForAnyConsonant.endIndex, offsetBy: self.postpositionForAnyVowel.count - self.postpositionForAnyConsonant.count))])
            }
            else {
                postpositionForAnyConsonant = self.postpositionForAnyConsonant
            }
            postpositionForAnyVowel = self.postpositionForAnyVowel
            if !postpositionForAnyConsonant.isEmpty {
                postposition = "(\(postpositionForAnyConsonant))\(postpositionForAnyVowel)"
            }
            else {
                postposition = postpositionForAnyVowel
            }
            return self.string + (postposition ?? "")
        }

        fileprivate init
            (string: String,
             postpositionForAnyConsonant: String = "을",
             postpositionForAnyVowel: String = "를")
        {
            self.string = string
            self.postpositionForAnyConsonant = postpositionForAnyConsonant
            self.postpositionForAnyVowel = postpositionForAnyVowel
        }
    }

    public struct Eul_Reul: KoreanigaProtocol {

        public let string: String

        fileprivate let postpositionForAnyConsonant: String
        fileprivate let postpositionForAnyVowel: String

        public var description: String {
            let decomposed = self.string.decomposedStringWithCanonicalMapping
            var postposition: String?
            for scalar in decomposed.unicodeScalars.reversed() {
                switch UInt(scalar.value) {
                case 0x1161 ... 0x1175:
                    postposition = self.postpositionForAnyVowel
                case 0x11a8 ... 0x11c2:
                    postposition = self.postpositionForAnyConsonant
                default:
                    continue
                }
                break
            }
            if postposition == nil {
                if self.postpositionForAnyVowel.isEmpty {
                    postposition = "(\(self.postpositionForAnyConsonant))"
                }
                else {
                    let postpositionForAnyConsonant: String
                    let postpositionForAnyVowel: String
                    if self.postpositionForAnyConsonant.hasSuffix(self.postpositionForAnyVowel) {
                        postpositionForAnyConsonant = String(self.postpositionForAnyConsonant[..<(self.postpositionForAnyConsonant.index(self.postpositionForAnyConsonant.endIndex, offsetBy: self.postpositionForAnyVowel.count - self.postpositionForAnyConsonant.count))])
                    }
                    else {
                        postpositionForAnyConsonant = self.postpositionForAnyConsonant
                    }
                    postpositionForAnyVowel = self.postpositionForAnyVowel
                    if !postpositionForAnyConsonant.isEmpty {
                        postposition = "(\(postpositionForAnyConsonant))\(postpositionForAnyVowel)"
                    }
                    else {
                        postposition = postpositionForAnyVowel
                    }
                }
            }
            return self.string + (postposition ?? "")
        }

        public var debugDescription: String {
            var postposition: String?
            let postpositionForAnyConsonant: String
            let postpositionForAnyVowel: String
            if self.postpositionForAnyConsonant.hasSuffix(self.postpositionForAnyVowel) {
                postpositionForAnyConsonant = String(self.postpositionForAnyConsonant[..<(self.postpositionForAnyConsonant.index(self.postpositionForAnyConsonant.endIndex, offsetBy: self.postpositionForAnyVowel.count - self.postpositionForAnyConsonant.count))])
            }
            else {
                postpositionForAnyConsonant = self.postpositionForAnyConsonant
            }
            postpositionForAnyVowel = self.postpositionForAnyVowel
            if !postpositionForAnyConsonant.isEmpty {
                postposition = "(\(postpositionForAnyConsonant))\(postpositionForAnyVowel)"
            }
            else {
                postposition = postpositionForAnyVowel
            }
            return self.string + (postposition ?? "")
        }

        fileprivate init
            (string: String,
             postpositionForAnyConsonant: String = "을",
             postpositionForAnyVowel: String = "를")
        {
            self.string = string
            self.postpositionForAnyConsonant = postpositionForAnyConsonant
            self.postpositionForAnyVowel = postpositionForAnyVowel
        }
    }

    public struct I: KoreanigaProtocol {

        public let string: String

        fileprivate let postpositionForAnyConsonant: String
        fileprivate let postpositionForAnyVowel: String

        public var ga: Koreaniga.I_Ga {
            return Koreaniga.I_Ga(string: self.string)
        }

        public var e: Koreaniga.IE_Ye {
            return Koreaniga.IE_Ye(string: self.string)
        }

        public var eo: Koreaniga.IEo_Yeo {
            return Koreaniga.IEo_Yeo(string: self.string)
        }

        public var eoss: Koreaniga.IEoss_Yeoss {
            return Koreaniga.IEoss_Yeoss(string: self.string)
        }

        public var o: Koreaniga.IO_Yo {
            return Koreaniga.IO_Yo(string: self.string)
        }

        public var description: String {
            let decomposed = self.string.decomposedStringWithCanonicalMapping
            var postposition: String?
            for scalar in decomposed.unicodeScalars.reversed() {
                switch UInt(scalar.value) {
                case 0x1161 ... 0x1175:
                    postposition = self.postpositionForAnyVowel
                case 0x11a8 ... 0x11c2:
                    postposition = self.postpositionForAnyConsonant
                default:
                    continue
                }
                break
            }
            if postposition == nil {
                if self.postpositionForAnyVowel.isEmpty {
                    postposition = "(\(self.postpositionForAnyConsonant))"
                }
                else {
                    let postpositionForAnyConsonant: String
                    let postpositionForAnyVowel: String
                    if self.postpositionForAnyConsonant.hasSuffix(self.postpositionForAnyVowel) {
                        postpositionForAnyConsonant = String(self.postpositionForAnyConsonant[..<(self.postpositionForAnyConsonant.index(self.postpositionForAnyConsonant.endIndex, offsetBy: self.postpositionForAnyVowel.count - self.postpositionForAnyConsonant.count))])
                    }
                    else {
                        postpositionForAnyConsonant = self.postpositionForAnyConsonant
                    }
                    postpositionForAnyVowel = self.postpositionForAnyVowel
                    if !postpositionForAnyConsonant.isEmpty {
                        postposition = "(\(postpositionForAnyConsonant))\(postpositionForAnyVowel)"
                    }
                    else {
                        postposition = postpositionForAnyVowel
                    }
                }
            }
            return self.string + (postposition ?? "")
        }

        public var debugDescription: String {
            var postposition: String?
            let postpositionForAnyConsonant: String
            let postpositionForAnyVowel: String
            if self.postpositionForAnyConsonant.hasSuffix(self.postpositionForAnyVowel) {
                postpositionForAnyConsonant = String(self.postpositionForAnyConsonant[..<(self.postpositionForAnyConsonant.index(self.postpositionForAnyConsonant.endIndex, offsetBy: self.postpositionForAnyVowel.count - self.postpositionForAnyConsonant.count))])
            }
            else {
                postpositionForAnyConsonant = self.postpositionForAnyConsonant
            }
            postpositionForAnyVowel = self.postpositionForAnyVowel
            if !postpositionForAnyConsonant.isEmpty {
                postposition = "(\(postpositionForAnyConsonant))\(postpositionForAnyVowel)"
            }
            else {
                postposition = postpositionForAnyVowel
            }
            return self.string + (postposition ?? "")
        }

        fileprivate init
            (string: String,
             postpositionForAnyConsonant: String = "이",
             postpositionForAnyVowel: String = "")
        {
            self.string = string
            self.postpositionForAnyConsonant = postpositionForAnyConsonant
            self.postpositionForAnyVowel = postpositionForAnyVowel
        }
    }

    public struct I_Ga: KoreanigaProtocol {

        public let string: String

        fileprivate let postpositionForAnyConsonant: String
        fileprivate let postpositionForAnyVowel: String

        public var description: String {
            let decomposed = self.string.decomposedStringWithCanonicalMapping
            var postposition: String?
            for scalar in decomposed.unicodeScalars.reversed() {
                switch UInt(scalar.value) {
                case 0x1161 ... 0x1175:
                    postposition = self.postpositionForAnyVowel
                case 0x11a8 ... 0x11c2:
                    postposition = self.postpositionForAnyConsonant
                default:
                    continue
                }
                break
            }
            if postposition == nil {
                if self.postpositionForAnyVowel.isEmpty {
                    postposition = "(\(self.postpositionForAnyConsonant))"
                }
                else {
                    let postpositionForAnyConsonant: String
                    let postpositionForAnyVowel: String
                    if self.postpositionForAnyConsonant.hasSuffix(self.postpositionForAnyVowel) {
                        postpositionForAnyConsonant = String(self.postpositionForAnyConsonant[..<(self.postpositionForAnyConsonant.index(self.postpositionForAnyConsonant.endIndex, offsetBy: self.postpositionForAnyVowel.count - self.postpositionForAnyConsonant.count))])
                    }
                    else {
                        postpositionForAnyConsonant = self.postpositionForAnyConsonant
                    }
                    postpositionForAnyVowel = self.postpositionForAnyVowel
                    if !postpositionForAnyConsonant.isEmpty {
                        postposition = "(\(postpositionForAnyConsonant))\(postpositionForAnyVowel)"
                    }
                    else {
                        postposition = postpositionForAnyVowel
                    }
                }
            }
            return self.string + (postposition ?? "")
        }

        public var debugDescription: String {
            var postposition: String?
            let postpositionForAnyConsonant: String
            let postpositionForAnyVowel: String
            if self.postpositionForAnyConsonant.hasSuffix(self.postpositionForAnyVowel) {
                postpositionForAnyConsonant = String(self.postpositionForAnyConsonant[..<(self.postpositionForAnyConsonant.index(self.postpositionForAnyConsonant.endIndex, offsetBy: self.postpositionForAnyVowel.count - self.postpositionForAnyConsonant.count))])
            }
            else {
                postpositionForAnyConsonant = self.postpositionForAnyConsonant
            }
            postpositionForAnyVowel = self.postpositionForAnyVowel
            if !postpositionForAnyConsonant.isEmpty {
                postposition = "(\(postpositionForAnyConsonant))\(postpositionForAnyVowel)"
            }
            else {
                postposition = postpositionForAnyVowel
            }
            return self.string + (postposition ?? "")
        }

        fileprivate init
            (string: String,
             postpositionForAnyConsonant: String = "이",
             postpositionForAnyVowel: String = "가")
        {
            self.string = string
            self.postpositionForAnyConsonant = postpositionForAnyConsonant
            self.postpositionForAnyVowel = postpositionForAnyVowel
        }
    }

    public struct IE_Ye: KoreanigaProtocol {

        public let string: String

        fileprivate let postpositionForAnyConsonant: String
        fileprivate let postpositionForAnyVowel: String

        public var description: String {
            let decomposed = self.string.decomposedStringWithCanonicalMapping
            var postposition: String?
            for scalar in decomposed.unicodeScalars.reversed() {
                switch UInt(scalar.value) {
                case 0x1161 ... 0x1175:
                    postposition = self.postpositionForAnyVowel
                case 0x11a8 ... 0x11c2:
                    postposition = self.postpositionForAnyConsonant
                default:
                    continue
                }
                break
            }
            if postposition == nil {
                if self.postpositionForAnyVowel.isEmpty {
                    postposition = "(\(self.postpositionForAnyConsonant))"
                }
                else {
                    let postpositionForAnyConsonant: String
                    let postpositionForAnyVowel: String
                    if self.postpositionForAnyConsonant.hasSuffix(self.postpositionForAnyVowel) {
                        postpositionForAnyConsonant = String(self.postpositionForAnyConsonant[..<(self.postpositionForAnyConsonant.index(self.postpositionForAnyConsonant.endIndex, offsetBy: self.postpositionForAnyVowel.count - self.postpositionForAnyConsonant.count))])
                    }
                    else {
                        postpositionForAnyConsonant = self.postpositionForAnyConsonant
                    }
                    postpositionForAnyVowel = self.postpositionForAnyVowel
                    if !postpositionForAnyConsonant.isEmpty {
                        postposition = "(\(postpositionForAnyConsonant))\(postpositionForAnyVowel)"
                    }
                    else {
                        postposition = postpositionForAnyVowel
                    }
                }
            }
            return self.string + (postposition ?? "")
        }

        public var debugDescription: String {
            var postposition: String?
            let postpositionForAnyConsonant: String
            let postpositionForAnyVowel: String
            if self.postpositionForAnyConsonant.hasSuffix(self.postpositionForAnyVowel) {
                postpositionForAnyConsonant = String(self.postpositionForAnyConsonant[..<(self.postpositionForAnyConsonant.index(self.postpositionForAnyConsonant.endIndex, offsetBy: self.postpositionForAnyVowel.count - self.postpositionForAnyConsonant.count))])
            }
            else {
                postpositionForAnyConsonant = self.postpositionForAnyConsonant
            }
            postpositionForAnyVowel = self.postpositionForAnyVowel
            if !postpositionForAnyConsonant.isEmpty {
                postposition = "(\(postpositionForAnyConsonant))\(postpositionForAnyVowel)"
            }
            else {
                postposition = postpositionForAnyVowel
            }
            return self.string + (postposition ?? "")
        }

        fileprivate init
            (string: String,
             postpositionForAnyConsonant: String = "이에",
             postpositionForAnyVowel: String = "예")
        {
            self.string = string
            self.postpositionForAnyConsonant = postpositionForAnyConsonant
            self.postpositionForAnyVowel = postpositionForAnyVowel
        }
    }

    public struct IEo_Yeo: KoreanigaProtocol {

        public let string: String

        fileprivate let postpositionForAnyConsonant: String
        fileprivate let postpositionForAnyVowel: String

        public var description: String {
            let decomposed = self.string.decomposedStringWithCanonicalMapping
            var postposition: String?
            for scalar in decomposed.unicodeScalars.reversed() {
                switch UInt(scalar.value) {
                case 0x1161 ... 0x1175:
                    postposition = self.postpositionForAnyVowel
                case 0x11a8 ... 0x11c2:
                    postposition = self.postpositionForAnyConsonant
                default:
                    continue
                }
                break
            }
            if postposition == nil {
                if self.postpositionForAnyVowel.isEmpty {
                    postposition = "(\(self.postpositionForAnyConsonant))"
                }
                else {
                    let postpositionForAnyConsonant: String
                    let postpositionForAnyVowel: String
                    if self.postpositionForAnyConsonant.hasSuffix(self.postpositionForAnyVowel) {
                        postpositionForAnyConsonant = String(self.postpositionForAnyConsonant[..<(self.postpositionForAnyConsonant.index(self.postpositionForAnyConsonant.endIndex, offsetBy: self.postpositionForAnyVowel.count - self.postpositionForAnyConsonant.count))])
                    }
                    else {
                        postpositionForAnyConsonant = self.postpositionForAnyConsonant
                    }
                    postpositionForAnyVowel = self.postpositionForAnyVowel
                    if !postpositionForAnyConsonant.isEmpty {
                        postposition = "(\(postpositionForAnyConsonant))\(postpositionForAnyVowel)"
                    }
                    else {
                        postposition = postpositionForAnyVowel
                    }
                }
            }
            return self.string + (postposition ?? "")
        }

        public var debugDescription: String {
            var postposition: String?
            let postpositionForAnyConsonant: String
            let postpositionForAnyVowel: String
            if self.postpositionForAnyConsonant.hasSuffix(self.postpositionForAnyVowel) {
                postpositionForAnyConsonant = String(self.postpositionForAnyConsonant[..<(self.postpositionForAnyConsonant.index(self.postpositionForAnyConsonant.endIndex, offsetBy: self.postpositionForAnyVowel.count - self.postpositionForAnyConsonant.count))])
            }
            else {
                postpositionForAnyConsonant = self.postpositionForAnyConsonant
            }
            postpositionForAnyVowel = self.postpositionForAnyVowel
            if !postpositionForAnyConsonant.isEmpty {
                postposition = "(\(postpositionForAnyConsonant))\(postpositionForAnyVowel)"
            }
            else {
                postposition = postpositionForAnyVowel
            }
            return self.string + (postposition ?? "")
        }

        fileprivate init
            (string: String,
             postpositionForAnyConsonant: String = "이어",
             postpositionForAnyVowel: String = "여")
        {
            self.string = string
            self.postpositionForAnyConsonant = postpositionForAnyConsonant
            self.postpositionForAnyVowel = postpositionForAnyVowel
        }
    }

    public struct IEoss_Yeoss: KoreanigaProtocol {

        public let string: String

        fileprivate let postpositionForAnyConsonant: String
        fileprivate let postpositionForAnyVowel: String

        public var description: String {
            let decomposed = self.string.decomposedStringWithCanonicalMapping
            var postposition: String?
            for scalar in decomposed.unicodeScalars.reversed() {
                switch UInt(scalar.value) {
                case 0x1161 ... 0x1175:
                    postposition = self.postpositionForAnyVowel
                case 0x11a8 ... 0x11c2:
                    postposition = self.postpositionForAnyConsonant
                default:
                    continue
                }
                break
            }
            if postposition == nil {
                if self.postpositionForAnyVowel.isEmpty {
                    postposition = "(\(self.postpositionForAnyConsonant))"
                }
                else {
                    let postpositionForAnyConsonant: String
                    let postpositionForAnyVowel: String
                    if self.postpositionForAnyConsonant.hasSuffix(self.postpositionForAnyVowel) {
                        postpositionForAnyConsonant = String(self.postpositionForAnyConsonant[..<(self.postpositionForAnyConsonant.index(self.postpositionForAnyConsonant.endIndex, offsetBy: self.postpositionForAnyVowel.count - self.postpositionForAnyConsonant.count))])
                    }
                    else {
                        postpositionForAnyConsonant = self.postpositionForAnyConsonant
                    }
                    postpositionForAnyVowel = self.postpositionForAnyVowel
                    if !postpositionForAnyConsonant.isEmpty {
                        postposition = "(\(postpositionForAnyConsonant))\(postpositionForAnyVowel)"
                    }
                    else {
                        postposition = postpositionForAnyVowel
                    }
                }
            }
            return self.string + (postposition ?? "")
        }

        public var debugDescription: String {
            var postposition: String?
            let postpositionForAnyConsonant: String
            let postpositionForAnyVowel: String
            if self.postpositionForAnyConsonant.hasSuffix(self.postpositionForAnyVowel) {
                postpositionForAnyConsonant = String(self.postpositionForAnyConsonant[..<(self.postpositionForAnyConsonant.index(self.postpositionForAnyConsonant.endIndex, offsetBy: self.postpositionForAnyVowel.count - self.postpositionForAnyConsonant.count))])
            }
            else {
                postpositionForAnyConsonant = self.postpositionForAnyConsonant
            }
            postpositionForAnyVowel = self.postpositionForAnyVowel
            if !postpositionForAnyConsonant.isEmpty {
                postposition = "(\(postpositionForAnyConsonant))\(postpositionForAnyVowel)"
            }
            else {
                postposition = postpositionForAnyVowel
            }
            return self.string + (postposition ?? "")
        }

        fileprivate init
            (string: String,
             postpositionForAnyConsonant: String = "이었",
             postpositionForAnyVowel: String = "였")
        {
            self.string = string
            self.postpositionForAnyConsonant = postpositionForAnyConsonant
            self.postpositionForAnyVowel = postpositionForAnyVowel
        }
    }

    public struct IO_Yo: KoreanigaProtocol {

        public let string: String

        fileprivate let postpositionForAnyConsonant: String
        fileprivate let postpositionForAnyVowel: String

        public var description: String {
            let decomposed = self.string.decomposedStringWithCanonicalMapping
            var postposition: String?
            for scalar in decomposed.unicodeScalars.reversed() {
                switch UInt(scalar.value) {
                case 0x1161 ... 0x1175:
                    postposition = self.postpositionForAnyVowel
                case 0x11a8 ... 0x11c2:
                    postposition = self.postpositionForAnyConsonant
                default:
                    continue
                }
                break
            }
            if postposition == nil {
                if self.postpositionForAnyVowel.isEmpty {
                    postposition = "(\(self.postpositionForAnyConsonant))"
                }
                else {
                    let postpositionForAnyConsonant: String
                    let postpositionForAnyVowel: String
                    if self.postpositionForAnyConsonant.hasSuffix(self.postpositionForAnyVowel) {
                        postpositionForAnyConsonant = String(self.postpositionForAnyConsonant[..<(self.postpositionForAnyConsonant.index(self.postpositionForAnyConsonant.endIndex, offsetBy: self.postpositionForAnyVowel.count - self.postpositionForAnyConsonant.count))])
                    }
                    else {
                        postpositionForAnyConsonant = self.postpositionForAnyConsonant
                    }
                    postpositionForAnyVowel = self.postpositionForAnyVowel
                    if !postpositionForAnyConsonant.isEmpty {
                        postposition = "(\(postpositionForAnyConsonant))\(postpositionForAnyVowel)"
                    }
                    else {
                        postposition = postpositionForAnyVowel
                    }
                }
            }
            return self.string + (postposition ?? "")
        }

        public var debugDescription: String {
            var postposition: String?
            let postpositionForAnyConsonant: String
            let postpositionForAnyVowel: String
            if self.postpositionForAnyConsonant.hasSuffix(self.postpositionForAnyVowel) {
                postpositionForAnyConsonant = String(self.postpositionForAnyConsonant[..<(self.postpositionForAnyConsonant.index(self.postpositionForAnyConsonant.endIndex, offsetBy: self.postpositionForAnyVowel.count - self.postpositionForAnyConsonant.count))])
            }
            else {
                postpositionForAnyConsonant = self.postpositionForAnyConsonant
            }
            postpositionForAnyVowel = self.postpositionForAnyVowel
            if !postpositionForAnyConsonant.isEmpty {
                postposition = "(\(postpositionForAnyConsonant))\(postpositionForAnyVowel)"
            }
            else {
                postposition = postpositionForAnyVowel
            }
            return self.string + (postposition ?? "")
        }

        fileprivate init
            (string: String,
             postpositionForAnyConsonant: String = "이오",
             postpositionForAnyVowel: String = "요")
        {
            self.string = string
            self.postpositionForAnyConsonant = postpositionForAnyConsonant
            self.postpositionForAnyVowel = postpositionForAnyVowel
        }
    }
}

extension String {

    public var ga: Koreaniga.I_Ga {
        let downstream = Koreaniga.I_Ga(string: self)
        return downstream
    }

    public var gwa: Koreaniga.Gwa_Wa {
        let downstream = Koreaniga.Gwa_Wa(string: self)
        return downstream
    }

    public var neun: Koreaniga.Eun_Neun {
        let downstream = Koreaniga.Eun_Neun(string: self)
        return downstream
    }

    public var ro: Koreaniga.EuRo_Ro {
        let downstream = Koreaniga.EuRo_Ro(string: self)
        return downstream
    }

    public var reul: Koreaniga.Eul_Reul {
        let downstream = Koreaniga.Eul_Reul(string: self)
        return downstream
    }

    public var a: Koreaniga.A_Ya {
        let downstream = Koreaniga.A_Ya(string: self)
        return downstream
    }

    public var ya: Koreaniga.A_Ya {
        let downstream = Koreaniga.A_Ya(string: self)
        return downstream
    }

    public var yeoss: Koreaniga.IEoss_Yeoss {
        let downstream = Koreaniga.IEoss_Yeoss(string: self)
        return downstream
    }

    public var ye: Koreaniga.IE_Ye {
        let downstream = Koreaniga.IE_Ye(string: self)
        return downstream
    }

    public var wa: Koreaniga.Gwa_Wa {
        let downstream = Koreaniga.Gwa_Wa(string: self)
        return downstream
    }

    public var eu: Koreaniga.Eu {
        let downstream = Koreaniga.Eu(string: self)
        return downstream
    }

    public var eun: Koreaniga.Eun {
        let downstream = Koreaniga.Eun(string: self)
        return downstream
    }

    public var euRo: Koreaniga.EuRo_Ro {
        let downstream = Koreaniga.EuRo_Ro(string: self)
        return downstream
    }

    public var eul: Koreaniga.Eul {
        let downstream = Koreaniga.Eul(string: self)
        return downstream
    }

    public var i: Koreaniga.I {
        let downstream = Koreaniga.I(string: self)
        return downstream
    }

    public var iEoss: Koreaniga.IEoss_Yeoss {
        let downstream = Koreaniga.IEoss_Yeoss(string: self)
        return downstream
    }

    public var iO: Koreaniga.IO_Yo {
        let downstream = Koreaniga.IO_Yo(string: self)
        return downstream
    }

    public init(_ koreaniga: KoreanigaProtocol) {
        self = koreaniga.description
    }
}

extension Koreaniga.Eu {

    @inlinable
    public var 로: Koreaniga.EuRo_Ro {
        return self.ro
    }
}

extension Koreaniga.Eun {

    @inlinable
    public var 는: Koreaniga.Eun_Neun {
        return self.neun
    }
}

extension Koreaniga.Eul {

    @inlinable
    public var 를: Koreaniga.Eul_Reul {
        return self.reul
    }
}

extension Koreaniga.I {

    @inlinable
    public var 가: Koreaniga.I_Ga {
        return self.ga
    }

    @inlinable
    public var 에: Koreaniga.IE_Ye {
        return self.e
    }

    @inlinable
    public var 어: Koreaniga.IEo_Yeo {
        return self.eo
    }

    @inlinable
    public var 었: Koreaniga.IEoss_Yeoss {
        return self.eoss
    }

    @inlinable
    public var 오: Koreaniga.IO_Yo {
        return self.o
    }
}

extension String {

    @inlinable
    public var 가: Koreaniga.I_Ga {
        return self.ga
    }

    @inlinable
    public var 과: Koreaniga.Gwa_Wa {
        return self.gwa
    }

    @inlinable
    public var 는: Koreaniga.Eun_Neun {
        return self.neun
    }

    @inlinable
    public var 로: Koreaniga.EuRo_Ro {
        return self.ro
    }

    @inlinable
    public var 를: Koreaniga.Eul_Reul {
        return self.reul
    }

    @inlinable
    public var 아: Koreaniga.A_Ya {
        return self.a
    }

    @inlinable
    public var 야: Koreaniga.A_Ya {
        return self.ya
    }

    @inlinable
    public var 였: Koreaniga.IEoss_Yeoss {
        return self.yeoss
    }

    @inlinable
    public var 예: Koreaniga.IE_Ye {
        return self.ye
    }

    @inlinable
    public var 와: Koreaniga.Gwa_Wa {
        return self.wa
    }

    @inlinable
    public var 으: Koreaniga.Eu {
        return self.eu
    }

    @inlinable
    public var 은: Koreaniga.Eun {
        return self.eun
    }

    @inlinable
    public var 으로: Koreaniga.EuRo_Ro {
        return self.euRo
    }

    @inlinable
    public var 을: Koreaniga.Eul {
        return self.eul
    }

    @inlinable
    public var 이: Koreaniga.I {
        return self.i
    }

    @inlinable
    public var 이었: Koreaniga.IEoss_Yeoss {
        return self.iEoss
    }

    @inlinable
    public var 이오: Koreaniga.IO_Yo {
        return self.iO
    }
}

extension Koreaniga.Eu {

    @inlinable
    public var 로: Koreaniga.EuRo_Ro {
        return self.ro
    }
}

extension Koreaniga.Eun {

    @inlinable
    public var 는: Koreaniga.Eun_Neun {
        return self.neun
    }
}

extension Koreaniga.Eul {

    @inlinable
    public var 를: Koreaniga.Eul_Reul {
        return self.reul
    }
}

extension Koreaniga.I {

    @inlinable
    public var 가: Koreaniga.I_Ga {
        return self.ga
    }

    @inlinable
    public var 에: Koreaniga.IE_Ye {
        return self.e
    }

    @inlinable
    public var 어: Koreaniga.IEo_Yeo {
        return self.eo
    }

    @inlinable
    public var 었: Koreaniga.IEoss_Yeoss {
        return self.eoss
    }

    @inlinable
    public var 오: Koreaniga.IO_Yo {
        return self.o
    }
}

extension String {

    @inlinable
    public var 가: Koreaniga.I_Ga {
        return self.ga
    }

    @inlinable
    public var 과: Koreaniga.Gwa_Wa {
        return self.gwa
    }

    @inlinable
    public var 는: Koreaniga.Eun_Neun {
        return self.neun
    }

    @inlinable
    public var 로: Koreaniga.EuRo_Ro {
        return self.ro
    }

    @inlinable
    public var 를: Koreaniga.Eul_Reul {
        return self.reul
    }

    @inlinable
    public var 아: Koreaniga.A_Ya {
        return self.a
    }

    @inlinable
    public var 야: Koreaniga.A_Ya {
        return self.ya
    }

    @inlinable
    public var 였: Koreaniga.IEoss_Yeoss {
        return self.yeoss
    }

    @inlinable
    public var 예: Koreaniga.IE_Ye {
        return self.ye
    }

    @inlinable
    public var 와: Koreaniga.Gwa_Wa {
        return self.wa
    }

    @inlinable
    public var 으: Koreaniga.Eu {
        return self.eu
    }

    @inlinable
    public var 은: Koreaniga.Eun {
        return self.eun
    }

    @inlinable
    public var 으로: Koreaniga.EuRo_Ro {
        return self.euRo
    }

    @inlinable
    public var 을: Koreaniga.Eul {
        return self.eul
    }

    @inlinable
    public var 이: Koreaniga.I {
        return self.i
    }

    @inlinable
    public var 이었: Koreaniga.IEoss_Yeoss {
        return self.iEoss
    }

    @inlinable
    public var 이오: Koreaniga.IO_Yo {
        return self.iO
    }
}
